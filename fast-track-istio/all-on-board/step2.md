In the last exercise, we deployed just one service to the mesh. In this exercise, we will deploy all the supporting services of the Book Club application. Before we do that, let's revisit the networking APIs of Istio.

- **ServiceEntry**: Adds additional entries to the service registry, such as virtual machines outside the cluster, or services outside the mesh that require communicating with the services in the mesh.
- **DestinationRule**: Defines policies such as load balancing and connection pool size applied after routing has taken effect.
- **VirtualService**: Defines routing rules that control the behavior of traffic routing to services.
- **Gateway**: Used to configure L4â€“L6 policies in the form of the load balancer for HTTP/TCP traffic at the edge of the mesh.
- **EnvoyFilter**: Describes a filter for Envoy that can be used to customize the proxy configuration generated by Pilot. This is a potent filter that can alter the internal working of Istio, and a wrong implementation can cripple the entire cluster. You will hardly find scenarios that require manipulating Envoy filters, and therefore, it is outside the scope of this book.
- **Sidecar**: Describes configuration of the sidecar proxy (remember, Envoy is just an implementation of sidecar). By default, Istio directs all traffic to a pod to travel via a proxy and the proxy to reach all services in the mesh. You can use this API to restrict access to a set of services and restrict the proxy to accept and forward traffic received on a set of ports and protocols. The sidecar networking API is outside the scope of this workshop.

Here is the high-level design diagram of the **Book Club** application.

![Book Club HLD](https://raw.githubusercontent.com/rahulrai-in/fast-track-istio/3f4a42abb0bc586bd197a62f9dbe93e645f3d583/assets/architecture.svg)

The **book-club** user interface is integrated into multiple services to serve books and movie information to the end-user. An externally hosted service named **independent service** serves both books and movies to the interface. The **movies service** has two versions that serve different genres of movies (we will explore versioning later). The **books service** also serves data from the **legacy service** through an endpoint. All the services serve data over HTTP through REST.

Let's inspect the specifications in the **my-workshop** folder as follows.

1. **bookclub-gw-vs-svc-deploy.yaml**: Specification of the gateway, virtual service, service, and deployment objects for the book-club user interface.
2. **books-api-svc-deploy.yaml**: Specification of the service, and deployment objects for the books api.
3. **legacy-api-svc-deploy.yaml**: Specification of the service, and deployment objects for the legacy api.
4. **movies-api-svc-deploy.yaml**: Specification of the service, and deployment objects for the movies api.

You must have noticed that we specified gateway and virtual service objects only for the book club user interface because the rest of the services do not need to be exposed outside the cluster.

Let's now deploy each of these mesh-enabled services to our cluster. The `kubectl` has a nifty tool called `kustomize` that you can use to process multiple Kubernetes specification files.

`kubectl kustomize my-workshop | kubectl apply -f -`{{execute}}

You can explore the user interface of the application at the following URL.

https://[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/

## Conclusion

We deployed all the components of our sample application to the Istio service mesh. We are now ready to explore the many features of Istio, which we will do next.
